/**
 * OpenClaw Bridge - Spawns actual OpenClaw sessions
 * 
 * This module integrates with OpenClaw's sessions_spawn API
 * to create isolated agent sessions that do real work.
 * 
 * For local dev/testing, can also run in "mock" mode.
 */

const fs = require('fs').promises;
const path = require('path');
const { spawn } = require('child_process');

class OpenClawBridge {
  constructor(options = {}) {
    this.options = {
      mode: options.mode || 'openclaw', // 'openclaw' | 'mock' | 'cli'
      defaultModel: options.model || 'sonnet',
      timeoutSeconds: options.timeoutSeconds || 300,
      ...options,
    };
    
    this.activeSessions = new Map();
  }

  /**
   * Spawn an agent session for a work item
   * Returns a promise that resolves when the agent completes
   */
  async spawnAgent(workItem, agentContext) {
    const { agentId, taskPrompt, workspaceDir, artifactsDir } = agentContext;
    
    console.log(`\nðŸ¤– Spawning OpenClaw agent: ${agentId}`);
    console.log(`   Mode: ${this.options.mode}`);
    console.log(`   Task: ${workItem.title}`);
    
    switch (this.options.mode) {
      case 'openclaw':
        return this.spawnOpenClawSession(workItem, agentContext);
      
      case 'cli':
        return this.spawnCliAgent(workItem, agentContext);
      
      case 'mock':
      default:
        return this.spawnMockAgent(workItem, agentContext);
    }
  }

  /**
   * Spawn via OpenClaw sessions_spawn API
   * This would be called from within an OpenClaw session
   */
  async spawnOpenClawSession(workItem, agentContext) {
    const { agentId, taskPrompt, workspaceDir, artifactsDir } = agentContext;
    
    // Build the full task with workspace context
    const fullTask = `
You are an isolated worker agent. Your workspace is: ${workspaceDir}

${taskPrompt}

IMPORTANT:
- Work only within your workspace directory
- Put all output files in: ${artifactsDir}
- When done, create ${artifactsDir}/COMPLETION.md with a summary
- If blocked, create ${workspaceDir}/BLOCKED.md explaining why

Begin working now.
`;

    // This would be invoked via OpenClaw's sessions_spawn
    // For now, return the config that would be passed
    const spawnConfig = {
      task: fullTask,
      label: `worker-${agentId}`,
      model: this.options.defaultModel,
      runTimeoutSeconds: this.options.timeoutSeconds,
      cleanup: 'keep', // Keep session for debugging
    };
    
    this.activeSessions.set(agentId, {
      config: spawnConfig,
      status: 'pending',
      startedAt: new Date().toISOString(),
    });
    
    return spawnConfig;
  }

  /**
   * Spawn via openclaw CLI (for external orchestration)
   */
  async spawnCliAgent(workItem, agentContext) {
    const { agentId, taskPrompt, workspaceDir, artifactsDir } = agentContext;
    
    return new Promise((resolve, reject) => {
      // Write task to a temp file
      const taskFile = path.join(workspaceDir, '.task.md');
      
      fs.writeFile(taskFile, taskPrompt)
        .then(() => {
          const proc = spawn('openclaw', [
            'run',
            '--task-file', taskFile,
            '--workdir', workspaceDir,
            '--timeout', String(this.options.timeoutSeconds),
          ], {
            cwd: workspaceDir,
            stdio: ['ignore', 'pipe', 'pipe'],
          });
          
          let output = '';
          
          proc.stdout.on('data', (data) => {
            output += data.toString();
          });
          
          proc.stderr.on('data', (data) => {
            console.error(`[${agentId}] stderr:`, data.toString());
          });
          
          proc.on('close', (code) => {
            resolve({
              agentId,
              exitCode: code,
              output,
            });
          });
          
          proc.on('error', (err) => {
            reject(err);
          });
          
          this.activeSessions.set(agentId, { proc, status: 'running' });
        })
        .catch(reject);
    });
  }

  /**
   * Mock agent for testing (simulates work)
   */
  async spawnMockAgent(workItem, agentContext) {
    const { agentId, taskPrompt, workspaceDir, artifactsDir } = agentContext;
    
    console.log(`   [MOCK] Simulating agent work...`);
    
    // Simulate some work time
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Create mock completion
    const completionContent = `# Completion Report

## Task
${workItem.title}

## Summary
[MOCK] This is a simulated completion. In production, a real agent would have done the work.

## Files Created
- example.txt (mock file)

## Notes
Mock agent completed successfully.

---
*Generated by mock agent at ${new Date().toISOString()}*
`;

    await fs.writeFile(
      path.join(artifactsDir, 'COMPLETION.md'),
      completionContent
    );
    
    // Create a mock artifact
    await fs.writeFile(
      path.join(artifactsDir, 'example.txt'),
      `Mock output for: ${workItem.title}\n`
    );
    
    console.log(`   [MOCK] Agent completed`);
    
    return {
      agentId,
      status: 'completed',
      mock: true,
    };
  }

  /**
   * Get session status
   */
  getSession(agentId) {
    return this.activeSessions.get(agentId);
  }

  /**
   * List active sessions
   */
  listSessions() {
    return Array.from(this.activeSessions.entries()).map(([id, session]) => ({
      id,
      ...session,
    }));
  }
}

// Singleton
let bridge = null;

function getBridge(options) {
  if (!bridge) {
    bridge = new OpenClawBridge(options);
  }
  return bridge;
}

module.exports = { OpenClawBridge, getBridge };
